package com.company.ipcamera.core.network.rtsp

import com.company.ipcamera.core.common.model.Resolution
import com.company.ipcamera.core.network.RtspClientStatus
import com.company.ipcamera.core.network.RtspFrame
import com.company.ipcamera.core.network.RtspStreamInfo
import com.company.ipcamera.core.network.RtspStreamType
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import kotlinx.cinterop.*
import kotlin.native.concurrent.*

// Импорт сгенерированных cinterop биндингов
// ВАЖНО: Раскомментируйте после генерации биндингов
import com.company.ipcamera.core.network.rtsp.rtsp_client.*

/**
 * Native реализация RTSP клиента через FFI
 * Использует cinterop для вызова нативных C++ функций
 */
actual class NativeRtspClient {
    
    // Thread-local хранилище для callbacks, чтобы избежать утечек памяти
    private val frameCallbacks = mutableMapOf<Long, StableRef<(RtspFrame) -> Unit>>()
    private val statusCallbacks = mutableMapOf<Long, StableRef<(RtspClientStatus, String?) -> Unit>>()
    
    actual fun create(): NativeRtspClientHandle {
        val client = rtsp_client_create()
        return client?.rawValue?.toLong() ?: 0L
    }

    actual suspend fun connect(
        handle: NativeRtspClientHandle,
        url: String,
        username: String?,
        password: String?,
        timeoutMs: Int
    ): Boolean = withContext(Dispatchers.Default) {
        val client = handleToPointer(handle) ?: return@withContext false
        memScoped {
            val urlPtr = url.cstr.ptr
            val usernamePtr = username?.cstr?.ptr
            val passwordPtr = password?.cstr?.ptr
            return@withContext rtsp_client_connect(client, urlPtr, usernamePtr, passwordPtr, timeoutMs.convert())
        }
    }

    actual suspend fun disconnect(handle: NativeRtspClientHandle) = withContext(Dispatchers.Default) {
        val client = handleToPointer(handle) ?: return@withContext
        rtsp_client_disconnect(client)
    }

    actual fun getStatus(handle: NativeRtspClientHandle): RtspClientStatus {
        val client = handleToPointer(handle) ?: return RtspClientStatus.DISCONNECTED
        val nativeStatus = rtsp_client_get_status(client)
        return convertNativeStatus(nativeStatus)
    }

    actual suspend fun play(handle: NativeRtspClientHandle): Boolean = withContext(Dispatchers.Default) {
        val client = handleToPointer(handle) ?: return@withContext false
        rtsp_client_play(client).toBoolean()
    }

    actual suspend fun stop(handle: NativeRtspClientHandle): Boolean = withContext(Dispatchers.Default) {
        val client = handleToPointer(handle) ?: return@withContext false
        rtsp_client_stop(client).toBoolean()
    }

    actual suspend fun pause(handle: NativeRtspClientHandle): Boolean = withContext(Dispatchers.Default) {
        val client = handleToPointer(handle) ?: return@withContext false
        rtsp_client_pause(client).toBoolean()
    }

    actual fun getStreamCount(handle: NativeRtspClientHandle): Int {
        val client = handleToPointer(handle) ?: return 0
        return rtsp_client_get_stream_count(client).toInt()
    }

    actual fun getStreamType(handle: NativeRtspClientHandle, streamIndex: Int): RtspStreamType? {
        val client = handleToPointer(handle) ?: return null
        val nativeType = rtsp_client_get_stream_type(client, streamIndex.convert())
        return convertNativeStreamType(nativeType)
    }

    actual fun getStreamInfo(handle: NativeRtspClientHandle, streamIndex: Int): RtspStreamInfo? {
        val client = handleToPointer(handle) ?: return null
        memScoped {
            val width = alloc<IntVar>()
            val height = alloc<IntVar>()
            val fps = alloc<IntVar>()
            val codecBuffer = allocArray<ByteVar>(64)
            
            val success = rtsp_client_get_stream_info(
                client,
                streamIndex.convert(),
                width.ptr,
                height.ptr,
                fps.ptr,
                codecBuffer,
                64.convert()
            )
            
            if (!success.toBoolean()) return null
            
            val nativeType = rtsp_client_get_stream_type(client, streamIndex.convert())
            val streamType = convertNativeStreamType(nativeType) ?: return null
            val codec = codecBuffer.toKString()
            val resolution = if (width.value > 0 && height.value > 0) {
                Resolution(width.value, height.value)
            } else {
                null
            }
            
            return RtspStreamInfo(
                index = streamIndex,
                type = streamType,
                resolution = resolution,
                fps = fps.value,
                codec = codec
            )
        }
    }

    actual fun setFrameCallback(
        handle: NativeRtspClientHandle,
        streamType: RtspStreamType,
        callback: (RtspFrame) -> Unit
    ) {
        val client = handleToPointer(handle) ?: return
        
        // Освобождаем предыдущий callback, если есть
        frameCallbacks[handle]?.dispose()
        
        // Создаем stable ref для callback
        val stableRef = StableRef.create(callback)
        frameCallbacks[handle] = stableRef
        
        val nativeStreamType = convertStreamType(streamType)
        
        // Создаем C callback функцию
        val nativeCallback: CPointer<Function1> = staticCFunction { framePtr: COpaquePointer?, userData: COpaquePointer? ->
            if (framePtr != null && userData != null) {
                val kotlinCallback = userData.asStableRef<(RtspFrame) -> Unit>().get()
                val frame = interpretObjCPointer<RTSPFrameVar>(framePtr)?.pointed
                if (frame != null) {
                    val kotlinFrame = convertNativeFrame(frame)
                    kotlinCallback(kotlinFrame)
                }
            }
        }
        
        rtsp_client_set_frame_callback(client, nativeStreamType, nativeCallback, stableRef.asCPointer())
    }

    actual fun setStatusCallback(
        handle: NativeRtspClientHandle,
        callback: (RtspClientStatus, String?) -> Unit
    ) {
        val client = handleToPointer(handle) ?: return
        
        // Освобождаем предыдущий callback, если есть
        statusCallbacks[handle]?.dispose()
        
        // Создаем stable ref для callback
        val stableRef = StableRef.create(callback)
        statusCallbacks[handle] = stableRef
        
        // Создаем C callback функцию
        val nativeCallback: CPointer<Function1> = staticCFunction { status: RTSPStatus, message: COpaquePointer?, userData: COpaquePointer? ->
            if (userData != null) {
                val kotlinCallback = userData.asStableRef<(RtspClientStatus, String?) -> Unit>().get()
                val messageStr = message?.toKString()
                val kotlinStatus = convertNativeStatus(status)
                kotlinCallback(kotlinStatus, messageStr)
            }
        }
        
        rtsp_client_set_status_callback(client, nativeCallback, stableRef.asCPointer())
    }

    actual fun destroy(handle: NativeRtspClientHandle) {
        val client = handleToPointer(handle) ?: return
        
        // Освобождаем callbacks
        frameCallbacks[handle]?.dispose()
        frameCallbacks.remove(handle)
        statusCallbacks[handle]?.dispose()
        statusCallbacks.remove(handle)
        
        rtsp_client_destroy(client)
    }
    
    // Вспомогательные функции конвертации
    
    private fun handleToPointer(handle: Long): CPointer<RTSPClientVar>? {
        return if (handle == 0L) null else interpretCPointer<RTSPClientVar>(handle)
    }
    
    private fun convertNativeStatus(status: RTSPStatus): RtspClientStatus {
        return when (status) {
            RTSP_STATUS_DISCONNECTED -> RtspClientStatus.DISCONNECTED
            RTSP_STATUS_CONNECTING -> RtspClientStatus.CONNECTING
            RTSP_STATUS_CONNECTED -> RtspClientStatus.CONNECTED
            RTSP_STATUS_PLAYING -> RtspClientStatus.PLAYING
            RTSP_STATUS_ERROR -> RtspClientStatus.ERROR
            else -> RtspClientStatus.DISCONNECTED
        }
    }
    
    private fun convertNativeStreamType(type: RTSPStreamType): RtspStreamType? {
        return when (type) {
            RTSP_STREAM_VIDEO -> RtspStreamType.VIDEO
            RTSP_STREAM_AUDIO -> RtspStreamType.AUDIO
            RTSP_STREAM_METADATA -> RtspStreamType.METADATA
            else -> null
        }
    }
    
    private fun convertStreamType(type: RtspStreamType): RTSPStreamType {
        return when (type) {
            RtspStreamType.VIDEO -> RTSP_STREAM_VIDEO
            RtspStreamType.AUDIO -> RTSP_STREAM_AUDIO
            RtspStreamType.METADATA -> RTSP_STREAM_METADATA
        }
    }
    
    private fun convertNativeFrame(frame: RTSPFrameVar): RtspFrame {
        val dataSize = rtsp_frame_get_size(frame.ptr).toInt()
        val dataPtr = rtsp_frame_get_data(frame.ptr)
        val timestamp = rtsp_frame_get_timestamp(frame.ptr)
        
        val data = if (dataPtr != null && dataSize > 0) {
            dataPtr.readBytes(dataSize)
        } else {
            ByteArray(0)
        }
        
        return RtspFrame(
            data = data,
            timestamp = timestamp,
            streamType = convertNativeStreamType(frame.type) ?: RtspStreamType.VIDEO,
            width = frame.width.toInt(),
            height = frame.height.toInt()
        )
    }
}

actual typealias NativeRtspClientHandle = Long

